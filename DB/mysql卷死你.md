## 索引

### 为什么要用索引
一股的应用系统，读写比例在10:1左右，而目插入操作和一没的更新操作很少出现性能问题，在生产环境中，我们
遇到最多的，也是最容易出问题的，还是一些复杂的查询換作，因此对查询语句的优化显然是重中之重。说起加速
查询，就不得不提到索引了。

### 什么是索引

索引在MysQL中也叫是一种“键”，是存储引擎用于快速战到记录的一种数据结构。
索引l对于良好的性能非常关键，尤其是当表中的数据量越来越大时，索引对于性能的影响愈发重要。
素引优化应该是对查询性能优化最有效的手段了。
索引能够轻易将查询性能提高好几个数量级。


### 索引的原理

索引的目的在于提高查询效率，与我们查阅图书所用的目录是一个道理：先定位到章，然后定位到该章下的一个小
节，然后找到页数。相似的例子还有：查字典，查火车车次，飞𢖯航班等

本质都是：通过不断地缩小想要获取数据的范国来筛选出最终想要的结果，同时把随机的事件变成顺序的事件，也
就是说，有了这种索引机制，我们可以总是用同一种香找方式来锁定数据.
数据库也是一样，但显然要复杂的多，因为不仅面临者等值查询，还有范围查询(。＜。between、in).模糊查询
dike)、并查询(or等等。数据库应该选择怎么样的方式来应对所有的问题呢


### 索引的类型
  普通索引：允许被索引的数据列包含重息的值
  唯一索引：可以保证数据记录的唯一性
  主键索引：是一种特殊的唯一索引，在一张表中只能定义一个主健泰引，主健用于唯一标识一条记录，使用关键字
  primary_key来创建

  联合索引：索引可以覆盖多个数据列
  全文索引：通过建立倒排索引，可以极大的提升检索效率，解決判断字段是否包含的问题，是目前搜索引擎使用的
  一种关键技术

索引可以极大地提高数据的杳询速度
通过使用素引，可以在直询的过程中，使用优化隐藏器，提高系统的性能
但是会降低插入、刪除、更新表的速度，因为在执行这些写操作的时候，还要操作索引文件

索引占物理空间，除了数据表上数据空间之外，每一个素三还积占一产的物甲空间，如果西简历聚镜索,那么 
么需梦的空间就会更大,如果非聚笈索引很多,一旦聚筷索引改变.那么所有非聚镇索引都会跟若变

### 索引的数据结构

数据结构:
     二叉树
     哈希表
     红黑树(二叉平衡数)
     BTree
     B+Tree
各种数据结构的优缺点

Innodb 采用 B+Tree索引
Memory 默认 hash索引

树哈希索引
两种索引的使用的优势不太相同.如果是等值查询,那么哈希算法会比较快. 
哈希算法若是 进行范围查询则不太行,也不支持like

MySOL中，只有Memory(Memory表只存在内存中，断电会消失，适用于临时表)存储引擎品示支持Hash索引,
是Memory表的默认索引类型，尽管Memory表也可以使用B+Tree索引。Hash索引把数据以hash形式组织起来
因此当查找某一条记录的时候，速度非常快。但是因为hash结构，每个键只对应一个值，而且是散列的方式分
布。所以它井不支持范困查找和排序等功能。

B+Tree是mysal使用最频餐的一个索引数据结构，是InnoDB和MVISAM存储引擎模式的索引类型。相对Hash索
引，B+Tree在查找单条记录的速度比不上Hash索引，但是因为更适合排序等操作，所以它更受欢迎。毕竞不可能
只对数据库进行单条记录的操作。

对比：
hash类型的索引：查询单条快，范圃查询慢
btree类型的索引：b+树，层数越多，数据最指数级增长（我们就用它，因为innodb默认支持它)

```SQL
//innodb 索引页大小 大约16KB
SHOW CLOBAL STATUS like ‘innodb_page_size’

```

### mysql聚簇索引和非聚簇索引的区别?

数据和索引放在同一个文件夹下就是 聚蔟索引, 不在则是非聚蔟索引

  mysql的索引与存储引擎相关, innobd  idb文件, myisan  方在 myd文件,

innodb 是聚簇索引,myisam 中只有非聚簇索引

mysal的索引类型跟存储引擎是相关的,innodb存储引擎数据文件跟索引文件全部放在ibd文件中，
而myisam的数据文件放在myd文件中,索引放在myi文件中，其实区分聚续索引(和非聚族索引非常简单，只要判断
数据跟索引是否存储在一起就可以了。

innodb存储引擎在进行数据插入的时候，数据必须要跟索引放在一起，如果有主键就使用主键，没有主键就
使用唯一键，没有唯一键就使用6字节的rowid，因此跟教据綁定在一起的就是紧族索引，而为了避免数据冗余存
储，其他的索引的叶子节点中存储的都是紧族索引的key值，因linnodb中既有聚筷索引也有非紧筷索引，而
myisam中只有非聚族索引。

### 索引的设计原则
在进行索引设计的时候，应该保证索引字段占用的空间越小越好，这只是一个大的方向，还有一些细节点需
要注意下：
1、适合索引的列是出现在Where字句中的列，或者连接子句中指定的列
T
2.其数较小的表，索引效果差，没必要创建索引
3、在选择索引列的时候，越短越好，可以指定其些列的一部分，没必要用全部字殷的價
4.不要给表中的每-
一个字段都创建泰引，井不是索引越多越好
5.定义有外键的数据列一定要创建索引
6、更新频繁的宇段不要有索引
7、创建索引的列不要过多，可以创建组合泰引，但是组合索引的列的个数不建议太多
8、大文木、大对象不要创建泰引
索引的优化细节
索引失效的情况
SQL回表


mysql为什么要存在索引系统
mysql索引应该如何设计
mysqI索引的数据结构选择
mysql索引的分类
详解mysql的回表和索引覆盖问题
详解mysql的最左匹配和索引下推
如何优雅的回答mysql索引面试题
mysql的索引原理和数据结构能介绍下吗

B+树跟B树的区别是什么
  结构不同

mysql聚簇索引和非聚簇索引的区别
  索引存储的位置不同


使用mysql索引都有什么原则

### SQL调优

   如何回答mysql的调优问题

   如何处理mysql的慢查询

   mysql如何进行性能监控

   schema和数据类型优化

## 事物

### ACID 是靠什么保证的
原子性  由undolog日志保证,它记录回滚的日志信息,事务回滚时撤销已经执行的SQL
一致性  由其他三大特性保证，程序代码要保证业务上的一致性
隔离性  由MVCC来保证
持久性  redolog来保证，mysql修改数据的时候会在redolog中记录一份日志数据，就算数据没有保存成功，只要
日志保存成功了，数据仍然不会丢失

索引最左原则

### 事务并发的问题
并发引起的问题
* 脏读(Dirty Read)
当一个車务正在访问数据并且对数据进行了修改，而这和修改还没有提交到数据库中，这时另外一个車务也访问了这个数据，然后使用了
这个数据。因为这个数据是还没有提交的数据，那么另外一个中务读到的这个数据是 〝脏数据〞
依据“脏数据〞所做的操作可能是不正确的。


时间点    | 事务 A   | 事务 B
---------|----------|---------
 1       | 开启事务A   | 
 2       |            |开启事务B
 3       | 查询余额100 | 
 4       |            | 增加余额到150
 5       | 查询余额150 | 
 6       |            | 事务回滚



* 不可重复读 Unrepeatableread)
  指在一个串务内多次读同一数据。在这个串务还没有结束时，的两次读数据之间，由于第二个事务的修改导致第一
另一个事务也访问该数据。那么，在第一个串务中个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，
因此称为不可重复读

时间点    | 事务 A   | 事务 B
---------|----------|---------
 1       | 开启事务A   | 
 2       |            |开启事务B
 3       | 查询余额100 | 
 4       |            | 增加余额到150
 5       | 查询余额100 | 
 6       |            | 事务提交
 7       |  查询余额150 | 

* 幻读(Phantom read)
幻读与不可重复读类似。它发生在一个事务 (T1）读取了几行数据，接岩另一个并发事务 (T2）插入了一业数据时
在殖后的查询中，第一个事务(T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻法。

时间点    | 事务 A   | 事务 B
---------|----------|---------
 1       | 开启事务A   | 
 2       |            |开启事务B
 3       | 查询id < 10, 共 5 条| 
 4       |            | 插入数据二条数据id =2,3
 5       |            | 事务提交
 6       |            | 
 7        |  查询id < 10 , 共 7 条| 

> 不可重复读和幻读的区别: 不可重复度重点是修改,幻读的重点在于新增或者修改


### Mysql的隔离级别有哪些

通过设置事务的隔离级别来来解决事务问题

**READ UNCOMMITED (读取未提交内容 )**

**READ COMMITED (读取提交内容)**

**REPEATEABLE READ (可重复读)**

**SERIALIZEABLE (可以串行化)**

不同的情况下出现 脏读,幻读,不可重复读

隔离级别    | 脏读    | 不可重复读 | 幻读
---------|----------|--------- |-------
 1       |   √ |√ |√
 2       |   × |√ |√
 3       |   × | ×|√
 4       |   × | ×| √
PS: √ 代表会出现问题, × 代表不回出现问题 = 解决问题


```sql
-- 查看默认的务隔高級別 MySOL默认的是repeatable read
select @et ransaction_isolation;
-- 设置当前回话的隔离级别
set session transaction isolation level read uncommitted;
set session transaction isolation level read committed;
set session transaction isolation level repeatable read;
set session transaction isolation level  serializable:
```

### RC 和 RR级别下的innoDB快照有什么不同
RC(READ COMMITED) RR(REPEATEABLE READ)
因为Read View生成时机的不同，从而造成RC、RR级别下快照读的结果的不同
1、在RR级别下的某个車务的对某条记录的第一次饮照读会创建一个快照即Read View,将当前系统活跃的其他
事务记录起来，此后在调用快照读的时候，还是使用的是同—个Read view,所以只要当前車务在其他事务提交更
新之前使用过快照读，那么之后的快照读使用的都是同一个Read View,所以对之后的修改不可见
2、在R尺级别下，快照读生成Read View时，Read View会记录此时所有其他活动和中务的快照，这些車务的
修攻对于当前丰务都是不可见的，而早于Read View创建的事务所做的修改均是可见
在RC级别下，丰务中，每次快路读都会新生成一个快照和Read view汶就是我们在RC级别下的丰务中可
以君到别的事务保交的重新的原因.

总结：在READ COMMITED的 隔离级别下，是每个快照读都会生成并获取最新的Read view,而在RR隔离级别下，
则是同一个
事务中的第第一个快照读才会创建Read View,之后的快照读获取的都是同一个Read view


## MySQL中的锁

基础锁的属性分类: 共享锁(读锁) 排他锁(写锁)

基于锁的粒度分类: 行级别(innodb), 表级别(innodb, myisam), 页级别(innodb), 记录锁, 间隙锁, 临建锁

基于锁的状态分类: 意向共享锁,意向排它锁

* 共字锁 (share lock)：共字锁又称读锁，简称S锁;当一个事务为数据加上读锁之后，其他事务只能对该数据
加读锁，而不能对数据加写锁，直到所有的读锁释放之后其他事务才能对其进行加持写锁。共字锁的特性主要是为
了支持井发的读取数据，读取数据的时候不支持修改，避免出现重复读的问题。

* 排他锁 (exclusive lock)：排他锁又称写锁，简称X锁;当一个事务为数据加上写锁时，其他请求将不能再为数
据加任何锁，直到该锁释放之后，其他事务才能对数据进行加锁。排他锁的目的是在数据修改时候，不允许其他人
同时修改，也不允许其他人读取，避免了出现脏数据和胜读的问题。

* 表锁 (table lock)：表锁是指上锁的时候锁佳的是整个表，当下一个重务访问该表的时候，必须等前一个事务释
放了锁才能进行对表进行访问;特点：粒度大，加锁简单，容易冲突；
行锁：行锁是指上锁的时侯锁住的是表的某一行或多行记录，其他事务访问同一张表时，只有被锁住的记录不能访
问，其他的记录可正常访问，特点：粒度小，加锁比表锁麻烦，不容易冲突，相比表锁支持的并发耍高

* 记录锁 (Record lock）;记录锁也届于行锁中的一种，只不过记录锁的范围只是表中的某一条记录，记录锁是说事
务在加锁后锁住的只是表的某一条记录，加了记录锁之后数据可以避免数据在查询的时候被修改的重复读问题，
也

* 页锁：页级锁是 MysOL 中锁定粒度介于行级锁和表级锁中间的一种锁．表级锁速度快，但冲突多，行级冲突少
但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。特点：开销和加锁时间界于表锁和行锁之间，会出现
死锁；锁定粒度界于表锁和行锁之间，并发度一設。

* 间隙锁：是居于行锁的一种，间隙锁是在事务加锁后其锁住的是表记录的某一个区间，当表的相邻1D之间出现空
隙则会形成一个区间，连盾左开右闭原则。范围查询井目查询末命中记录，查询条件必须命中索引间隙锁只会出
现在REPEATABLE READ（重复读）的事务级别中。

* 临键锁 (Next-Kev lock)：也届于行锁的一种，并目它是INNODB的行锁默认身法，总结来说它就是记录锁和间隙
锁的组合，临键锁会把查询出来的记录锁住，同时市

* 临键锁 (Next-Kev lock)：也居于行锁的一种，并旦它是INNODB的行锁默认算法，总结来说它就是记录锁和问隙
锁的组合，临键锁会把查询出来的记录锁住，同时也会把该范围查询内的所有间隙空间也会锁住，再之它会把相邻
的下一个区间也会锁住

避免了在修改的事务末捍交前被其他事务读取的𥅾读问题

### MYSQL的锁机制实现

###  什么是mysql的主从复制

### mysql复制的原理是什么

  通过binary log  和 IO thread 来实现
 



mysql面试常见点--事务
mysql面试常见点--mysql集群
 mysql面试常见点--mysql优化
 mysql面试常见点--存储引擎
 mysql面试题--mysql原子性和持久性怎么保证
 innodb和myisam区别
mysql面试题--索引分类
mysql面试题--innodb的底层数据结构

[Innodb 官网文档](https://dev.mysql.com/doc/refman/8.0/en/innodb-storage-engine.html)


mysql面试题性能监控
schema和数据类型优化
执行计划

mysql读写分离
事务的特点
事务的实现机制

### 什么是MVCC

1. MVCC
  
  MVCC， 全称Multi-Version Concurrency Control，即多版本并发控制。MVCC是一种并发控制的方法，
  在数据库管理系统中，实现对数据库的并发访问，在编程语言中实现事务内存。

> MVCC在MySOL InnoDB中的实现主要是为了提高数抵库并发性能，用更好的方式大处那读写冲灾，做到即使有读军冲
实时，出能做斜不加锁，非阻塞的并发读，

2. 当前读
   
  比如: select lock in share mode(共享锁), 
  select for update: update, insert delete(排他锁)这此操作都是一种
  当前读，为什么叫当前读？就是它读取的是记录的最新版本，读取时还要保证其他井发事务不能修改当前记录，会
  对谜取的记录进行加锁.

3. 块照读（提高数据库的井发查询能力）

  像不加锁的select操作就是快照读，即不加锁的非阻塞读;快照读的前捉是隔高级别不是串行级别，串行级别
  下的快照读会退化成当前读;之所以出现快照读的情况，是基于提高井发性能的考虑，快照读的实现是基于多版本
  并发控制, 即MVCC,可以认为MVCC是行锁的一个变种，但它在很多情况下，避免了加锁操作，降低了开销；
  既然是其于多版本，即快照读可能读到的井不一定是数据的最新版本，而有可能是之前的历史版本

4. 当前读、快照读、MVCC关系

  MIVCC多版本井发控制指的是维持一个数据的多个版本，使得读写操作没有冲突，快照读是MySQL为实现
  MVCC的一个非阳寒读功能。MVCC模块在MySOL中的具体实现是由三个隐式字段，undo日志、read view三个组

### MVCC是如何实现的?
* MVCC 机制主要依赖于记录中的三个隐藏字段, undolog,read view 来实现
  DB_TRX_ID
  最近修改的事务id   
   1,2,3 代表查询 ,4 代表Update
  DB_ROLL_PTR
  7b 回滚指针
  DB_ROW_ID
  6b, 隐藏主键
### MVCC解决什么问题?

数据库并发场景有三种，分别为：
  1. 读读：不存在任何问题，也不需亟并发控制
  2. 读写：有线程安全问题，可能会造成丰务阿离性问题，可能遇到脏读、幻读、不重复复读
  3. 写写：有线程安全问题，可能存在更新丢失问题

  MvCC是一种用来辉决洪写沖突的无做井发控制，也就是为申务分配单项规长的时间蛋，为每个修改保存
  版木,版木与中务时间戳关联, 读操作只读该申务开始前的数据库的快照,
  所以MVCC可以为数据库解決一下问顾：
  在并发读写数据库时，可以做到在读操作时不用阳寒写操作，写操作也不用阳寒读操作，提高了数据库并发读写的性能
  解决脏读、幻读．不可重复读等事务隔玄问题，但是不能解决重新丢失问题


### mysql为什么需要主从同步？
mysql主从复制搭建
  数据库实现读写分离
  1.在业务复杂的系统中，有这么一个情景，有一句sql语句需要锁表，号致暂时不能使用读的服务，那么就很影响
  运行中的业务，使用主从复制，让主库负费写，从库负责读，这样，即使主库出现了锁表的情景，通过读从库也可
  以保证业务的正常运作.

  2.做数据的热备
  3.架构的扩层。业务量越来越大，10访问频率过高，单机无法满足，此时做多库的存储，降低磁盘1/0访问的烦
  率，提高单个机器的1/0性能。
  


### 如何处理mysql的慢查询

1、开启慢查询日志，准确定位到哪个sql语句出现了问题
2、分析sql语句，看看是否load了额外的数据，可能是古询了多余的行井且抛奔掉了，可能是加载了许多结果中并
不需要的列，对语句进行分析以及重写
3、分析语句的执行计划，然后荻得其使用泰引的情况，之后修改语句或者修改泰引1，使得语句可以尽可能的命中
泰引
4、如果对语句的优化已经无法进行，可以考点表中的数据量是否太大，如果是的话可以进行横向或者纵向的分
表

### mysql执行计划怎么看

[去官网看](https://dev.mysglcom/doc/refman/5.7/en/explain-output.html)


  ```SQL
  explian SQL
  ```




磁盘遇读--> data page

列式数据库 
行式数据库
 OLAP 分析型处理
 OLTP 事务型处理


matlab to python
https://github.com/ebranlard/matlab2python